package cn.llonvne.copy

import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.*
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.writeTo

val PropertiesCopyAnnotationFqName = "cn.llonvne.llonvne.copy.PropertiesCopy"

class PropertiesProcessor(private val environment: SymbolProcessorEnvironment) : SymbolProcessor {

    data class Copy(val source: KSClassDeclaration, val targets: List<KSType>)

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val classes = resolver.getSymbolsWithAnnotation(PropertiesCopyAnnotationFqName)
        classes
            .filterIsInstance<KSClassDeclaration>()
            .map { source ->
                val targets = source.annotations
                    // FILTER PRO COPY ANNO
                    .filter { anno ->
                        anno.annotationType.resolve().toClassName().canonicalName == PropertiesCopyAnnotationFqName
                    }
                    // GET TARGET KCLASS
                    .map { anno ->
                        anno.arguments[0].value as KSType
                    }
                    .toList()
                Copy(source, targets)
            }
            .map {
                CopyResolver(copy = it, environment).resolve()
            }.forEach {
                it.writeTo(environment.codeGenerator, false)
            }
        return emptyList()
    }
}

class CopyResolver(private val copy: PropertiesProcessor.Copy, private val environment: SymbolProcessorEnvironment) {

    private val file = FileSpec.builder(copy.source.packageName.asString(), "PropertiesCopy")
        .also {
            it.addFileComment(
                """
                Generated By PropertiesCopy
            """.trimIndent()
            )
        }
    private val KSClassDeclaration.pubPcMembers
        get() = this.primaryConstructor!!.parameters.filter {
            !it.type.modifiers.contains(Modifier.PROTECTED) &&
                    !it.type.modifiers.contains(Modifier.PRIVATE)
        }

    private val KSClassDeclaration.pubPcMemberNoDefault
        get() = pubPcMembers.filter { !it.hasDefault }

    private val sourceMembers = copy.source.pubPcMembers
    private fun targetChecker(target: KSType) {
        require(target.declaration is KSClassDeclaration) {
            "must be a class"
        }
        val ksClassDeclaration = target.declaration as KSClassDeclaration
        require(Modifier.DATA in ksClassDeclaration.modifiers) {
            "must be a data class"
        }
        require(target.declaration.typeParameters.equals(0)) {
            "cannot know how to copy typeParameters"
        }
    }

    private fun sourceChecker() {
        require(Modifier.DATA in copy.source.modifiers) {
            "must be a data class"
        }
        requireNotNull(copy.source.primaryConstructor) {
            "must have a primary constructor"
        }
        require(copy.source.typeParameters.equals(0)) {
            "cannot know how to copy typeParameters"
        }
    }

    fun resolve(): FileSpec {
        sourceChecker()
        copy.targets.forEach { target ->
            file.addFunction(resolveEach(target))
        }
        return file.build()
    }

    private fun resolveEach(target: KSType): FunSpec {
        targetChecker(target)

        val targetPcParas = (target.declaration as KSClassDeclaration)
            .primaryConstructor!!.parameters

        val func = FunSpec.builder("`to${target.declaration.simpleName.asString()}`")
            .receiver(copy.source.toClassName())
            .returns(target.toClassName())

        val parameters = mutableListOf<KSValueParameter>()

        targetPcParas.forEach { parameter ->

            val result = sourceMembers.find {
                requireNotNull(parameter.name) == requireNotNull(it.name)
                        &&
                        requireNotNull(it.type.resolve().declaration.qualifiedName) ==
                        requireNotNull(parameter.type.resolve().declaration.qualifiedName)
            }
            if (result != null) {
                parameters.add(result)
            } else {
                if (!parameter.hasDefault) {
                    environment.logger.error("${parameter.name?.asString()} didn't appear in ${copy.source.simpleName} and not have default value")
                    throw IllegalStateException("!!!")
                }
            }
            // DEFAULT  == null, has default DO NOTHING
        }
        func.addCode(
            "return `${target.declaration.simpleName.asString()}`(${
                parameters.map { it.name?.asString() }.joinToString(",") {
                    "`$it`=`$it`"
                }
            })"
        )
        return func.build()
    }
}
